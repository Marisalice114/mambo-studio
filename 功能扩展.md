# 功能扩展

生成应用封面图

下载项目代码包

ai选择生成模式

## 生成应用封面图

1）首先要获取到应用的可访问URL。由于我们的平台支持多种生成模式（原生HTML、多文件项目、Vue工程），其中原
生模式和Vue工程模式生成可访问浏览URL的时机不一样。所以为了统一处理，而且确保应用已经可以正常访问，我们选择在应用部署完成后再生成封面图。
2）使用Selenium这样的自动化工具打开一个无头浏览器，访问应用页面并进行截图。
3）直接截图得到的图片通常比较大，不仅占用存储空间，加载速度也会比较慢。因此我们需要对图片进行压缩处理。
虽然我们可以通过调整Selenium的窗口大小来控制截图尺寸，但这样可能会导致页面显示不全。更好的方案是先按正常
尺寸截图，然后使用工具库对图片进行压缩。
4）为了确保图片的持久化存储和快速访问，将压缩后的图片上传到腾讯云COS对象存储中，并将访问URL保存到数据
库的应用表中。
5）最后，记得清理本地临时文件。

![image-20250808093549902](D:\ideaproject\mambo-ai-platform\assets\image-20250808093549902.png)

### selenium

Selenium是一个非常成熟的Web自动化框架，它的核心概念是WebDriver(浏览器驱动)。
WebDriver是一个可以控制浏览器行为的接口，能够让程序像人类一样操作浏览器：打开页面、点击按钮、输入文本、截
取屏幕等。可以说WebDriver是Selenium与浏览器之间的桥梁，因为不同浏览器(Chrome、Firefox、Safari等)有不同的内部API和控制机制，驱动程序负责将Selenium的标准化命令翻译成各个浏览器能理解的具体指令，从而实现跨浏览器的统一自动化控制。

由于之后需要对这个功能独立化，所以这个功能里应该不能强制绑定appid

生成图片操作也应该是异步操作

```java
    @Override
    public void generateAppScreenshotAsync(Long appId, String appDeployUrl) {
        // 异步生成应用封面截图
        Thread.startVirtualThread(() -> {
            try {
                // 生成应用封面截图
                String screenshotUrl = screenshotService.generateAndUploadScreenshot(appDeployUrl);
                if (StrUtil.isNotBlank(screenshotUrl)) {
                    // 更新应用的封面
                    App updateApp = new App();
                    updateApp.setId(appId);
                    updateApp.setCover(screenshotUrl);
                    this.updateById(updateApp);
                    log.info("应用 {} 的封面截图已生成并更新: {}", appId, screenshotUrl);
                } else {
                    log.warn("应用 {} 的封面截图生成失败", appId);
                }
            } catch (Exception e) {
                log.error("生成应用 {} 封面截图异常: {}", appId, e.getMessage(), e);
            }
        });
    }
```

这里我们使用了Java21的虚拟线程(VirtualThread)特性，这是由JVM管理的轻量级线程。它的创建成本极低(几乎无内存开销)，且在执行I/O操作时会自动让出CPU给其他虚拟线程，从而在同样的系统资源下支持百万级并发而不是传统平台线程的几千级并发。而且它的使用和传统Java线程几乎没有区别，非常适合处理这种1/O密集型的异步任务。

对象存储选择阿里云oss，根据文档来生成对应的逻辑

此处是采用的一个共用的webdriver，这样会出现并发问题，此处采用threadlocal来进行解决，每个threadlocal都给一个webdriver，这样每个线程的webdriver就是独立的

## 下载代码

将原始代码进行压缩，并且提供压缩包

注意要过滤掉一些文件，只需要保留一些开发的文件 -> 文件过滤器

最后将过滤后的文件打包成ZIP压缩包，通过HTTP响应直接返回给前端。需要设置正确的响应头，告诉浏览器这是一个需要下载的文件、并且传递下载的文件名称

## 智能路由

现在有三种代码方案，并且有各种各样的模型操作
所以现在需要在后端自动选择哪种代码生成模式

使用一些成本低，输出更快的大模型来进行调用哪种生成方式来进行判断

