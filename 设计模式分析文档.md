# Mambo AI Platform 设计模式分析文档

## 项目概述

本文档分析了 Mambo AI Platform 项目中使用的各种设计模式，该项目是一个基于 Spring Boot 的 AI 代码生成平台，使用了 LangChain4j 和 LangGraph4j 进行工作流编排。

## 设计模式清单

### 1. 工厂模式 (Factory Pattern)

#### 1.1 抽象工厂模式 - AiCodeGeneratorServiceFactory

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/ai/AiCodeGeneratorServiceFactory.java`

**实现说明**:

- 负责根据不同的应用 ID 和代码生成类型创建对应的 AI 服务实例
- 使用缓存机制优化性能，避免重复创建相同配置的服务
- 支持多种代码生成类型（HTML、MULTI_FILE、VUE_PROJECT）

```java
@Configuration
@Slf4j
public class AiCodeGeneratorServiceFactory {

    // 缓存策略：最大缓存1000个实例，写入后30分钟过期，访问后10分钟过期
    private final Cache<String, AiCodeGeneratorService> serviceCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .expireAfterAccess(Duration.ofMinutes(10))
            .build();

    public AiCodeGeneratorService getAiCodeGeneratorService(long appId, CodeGenTypeEnum codeGenType) {
        String cacheKey = buildCacheKey(appId, codeGenType);
        return serviceCache.get(cacheKey, key -> createAiCodeGeneratorService(appId, codeGenType));
    }
}
```

**优点**:

- 统一管理 AI 服务实例的创建
- 支持缓存机制，提升性能
- 易于扩展新的服务类型

#### 1.2 简单工厂模式 - ImageCollectionPlanServiceFactory

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/langgraph4j/ai/ImageCollectionPlanServiceFactory.java`

**实现说明**:

- 专门用于创建图片收集规划服务
- 使用 Spring 的@Bean 注解进行依赖注入管理

### 2. 门面模式 (Facade Pattern)

#### 2.1 AiCodeGeneratorFacade

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/core/AiCodeGeneratorFacade.java`

**实现说明**:

- 为复杂的 AI 代码生成系统提供统一的简化接口
- 隐藏了底层 TokenStream 处理、工具调用管理等复杂逻辑
- 提供同步和异步（流式）两种调用方式

```java
@Service
public class AiCodeGeneratorFacade {

    // 统一入口：根据类型生成并保存代码
    public File generateCodeAndSave(String userMessage, CodeGenTypeEnum codeGenTypeEnum, Long appId) {
        // 隐藏复杂的服务获取和类型判断逻辑
    }

    // 统一入口：根据类型生成并保存代码（流式）
    public Flux<String> generateCodeAndSaveStream(String userMessage, CodeGenTypeEnum codeGenTypeEnum, Long appId) {
        // 隐藏复杂的流式处理逻辑
    }
}
```

**优点**:

- 简化客户端调用
- 降低系统耦合度
- 统一错误处理和日志记录

### 3. 适配器模式 (Adapter Pattern)

#### 3.1 TokenStream 到 Flux 适配器

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/core/AiCodeGeneratorFacade.java`

**实现说明**:

- 将 LangChain4j 的 TokenStream 适配为 Reactor 的 Flux<String>
- 处理工具调用计数和流式响应转换

```java
/**
 * 将 TokenStream 转换为 Flux<String>，并传递工具调用信息 适配器模式
 */
private Flux<String> processTokenStream(TokenStream tokenStream) {
    return Flux.create(sink -> {
        // 工具调用计数器，用于监控（不设限制）
        final AtomicInteger toolCallCount = new AtomicInteger(0);

        tokenStream.onPartialResponse((String partialResponse) -> {
            AiResponseMessage aiResponseMessage = new AiResponseMessage(partialResponse);
            sink.next(JSONUtil.toJsonStr(aiResponseMessage));
        })
        .onPartialToolExecutionRequest((index, toolExecutionRequest) -> {
            // 适配工具调用请求
            ToolRequestMessage toolRequestMessage = new ToolRequestMessage(toolExecutionRequest);
            sink.next(JSONUtil.toJsonStr(toolRequestMessage));
        })
        // ... 其他适配逻辑
    });
}
```

**优点**:

- 实现不同框架间的无缝集成
- 保持代码的一致性和可维护性

### 4. 模板方法模式 (Template Method Pattern)

#### 4.1 BaseTool 抽象类

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/ai/tools/BaseTool.java`

**实现说明**:

- 定义工具类的通用接口和模板方法
- 子类实现具体的工具名称和执行逻辑

```java
public abstract class BaseTool {

    // 抽象方法，子类必须实现
    public abstract String getToolName();
    public abstract String getDisplayName();
    public abstract String generateToolExecutedResult(JSONObject arguments);

    // 模板方法，提供默认实现
    public String generateToolRequestResponse() {
        return String.format("\n\n[选择工具] %s\n\n", getDisplayName());
    }
}
```

**具体实现类**:

- WriteFileTool
- ReadFileTool
- ModifyFileTool
- DeleteFileTool
- ReadDirTool

### 5. 策略模式 (Strategy Pattern)

#### 5.1 代码解析器策略 - CodeParserExecutor

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/core/parser/CodeParserExecutor.java`

**实现说明**:

- 根据不同的代码生成类型选择相应的解析策略
- 使用 Java 14 的 switch 表达式实现策略选择

```java
public class CodeParserExecutor {

    private static final HtmlCodeParser htmlCodeParser = new HtmlCodeParser();
    private static final MultiFileCodeParser multiFileCodeParser = new MultiFileCodeParser();

    public static Object executeParser(String codeContent, CodeGenTypeEnum codeGenTypeEnum) {
        return switch (codeGenTypeEnum) {
            case HTML -> htmlCodeParser.parseCode(codeContent);
            case MULTI_FILE -> multiFileCodeParser.parseCode(codeContent);
            default -> throw new BusinessException(ErrorCode.SYSTEM_ERROR, "不支持的代码生成类型");
        };
    }
}
```

#### 5.2 代码保存器策略 - CodeFileSaverExecutor

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/core/saver/CodeFileSaverExecutor.java`

**实现说明**:

- 根据不同的代码生成类型选择相应的保存策略

```java
public class CodeFileSaverExecutor {

    private static final HtmlCodeFileSaverTemplate htmlCodeFileSaver = new HtmlCodeFileSaverTemplate();
    private static final MultiFileCodeFileSaverTemplate multiFileCodeFileSaver = new MultiFileCodeFileSaverTemplate();

    public static File executeSaver(Object codeResult, CodeGenTypeEnum codeGenType, Long appId) {
        return switch (codeGenType) {
            case HTML -> htmlCodeFileSaver.saveCode((HtmlCodeResult) codeResult, appId);
            case MULTI_FILE -> multiFileCodeFileSaver.saveCode((MultiFileCodeResult) codeResult, appId);
            default -> throw new BusinessException(ErrorCode.SYSTEM_ERROR, "不支持的代码生成类型: " + codeGenType);
        };
    }
}
```

### 6. 注册表模式 (Registry Pattern)

#### 6.1 工具管理器 - ToolManager

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/ai/tools/ToolManager.java`

**实现说明**:

- 统一管理所有工具实例
- 通过 Spring 的依赖注入自动注册所有 BaseTool 的实现类
- 提供根据名称查找工具的功能

```java
@Component
public class ToolManager {

    private final Map<String, BaseTool> toolMap = new HashMap<>();

    @Resource
    private BaseTool[] tools;  // Spring自动注入所有BaseTool实现

    @PostConstruct
    public void initTools() {
        for (BaseTool tool : tools) {
            toolMap.put(tool.getToolName(), tool);
            log.info("注册工具: {} -> {}", tool.getToolName(), tool.getDisplayName());
        }
    }

    public BaseTool getTool(String toolName) {
        return toolMap.get(toolName);
    }
}
```

**优点**:

- 统一管理工具注册和查找
- 支持动态工具发现
- 易于扩展新工具

### 7. 建造者模式 (Builder Pattern)

#### 7.1 实体类建造者

**使用位置**: 所有实体类和 VO 类

**实现说明**:

- 使用 Lombok 的@Builder 注解自动生成建造者模式代码
- 简化对象创建过程

```java
@Builder
public class User implements Serializable {
    // 字段定义
}

@Builder
public class UserAdminVO implements Serializable {
    // 字段定义
}
```

#### 7.2 AI 服务建造者

**文件位置**: `AiCodeGeneratorServiceFactory.java`中的服务创建

```java
// 使用AiServices的建造者模式创建AI服务
return switch (codeGenType) {
    case HTML, MULTI_FILE ->
        AiServices.builder(AiCodeGeneratorService.class)
                .streamingChatModel(openAiStreamingChatModel)
                .chatModel(chatModel)
                .chatMemory(chatMemory)
                .build();

    case VUE_PROJECT ->
        AiServices.builder(AiCodeGeneratorService.class)
                .streamingChatModel(reasoningStreamingChatModel)
                .chatMemoryProvider(memoryId -> chatMemory)
                .tools(toolManager.getAllTools())
                .build();
};
```

### 8. 工作流模式 (Workflow Pattern)

#### 8.1 LangGraph4j 工作流 - CodeGenWorkflow

**文件位置**: `src/main/java/com/hachimi/mamboaiplatform/langgraph4j/CodeGenWorkflow.java`

**实现说明**:

- 使用 LangGraph4j 实现复杂的 AI 代码生成工作流
- 包含多个节点：图片收集、提示增强、路由、代码生成、质量检查、项目构建

```java
public CompiledGraph<MessagesState<String>> createWorkflow() {
    return new MessagesStateGraph<String>()
            // 添加节点
            .addNode("image_collector", ImageCollectorNode.create())
            .addNode("prompt_enhancer", PromptEnhancerNode.create())
            .addNode("router", RouterNode.create())
            .addNode("code_generator", CodeGeneratorNode.create())
            .addNode("code_quality_check", CodeQualityCheckNode.create())
            .addNode("project_builder", ProjectBuilderNode.create())

            // 添加边（定义执行顺序）
            .addEdge(START, "image_collector")
            .addEdge("image_collector", "prompt_enhancer")
            .addEdge("prompt_enhancer", "router")
            // 条件边 - 根据路由结果决定下一步
            .addConditionalEdges("router", this::routeDecision, routeMap)
            .compile();
}
```

### 9. 依赖注入模式 (Dependency Injection Pattern)

#### 9.1 Spring 框架的依赖注入

**使用位置**: 整个项目

**实现说明**:

- 广泛使用@Resource、@Autowired 注解进行依赖注入
- 使用@Component、@Service、@Configuration 等注解管理 Bean 生命周期

```java
@Service
public class AiCodeGeneratorFacade {

    @Resource
    private AiCodeGeneratorServiceFactory aiCodeGeneratorServiceFactory;

    // 其他依赖注入
}
```

### 10. 观察者模式 (Observer Pattern)

#### 10.1 前端可视化编辑器

**文件位置**: `yu-ai-code-mother-frontend/src/utils/visualEditor.ts`

**实现说明**:

- VisualEditor 类实现观察者模式，监听元素选择和悬停事件

```typescript
export class VisualEditor {
  private options: VisualEditorOptions

  constructor(options: VisualEditorOptions = {}) {
    this.options = options
  }

  // 当元素被选中时通知观察者
  private notifyElementSelected(info: ElementInfo) {
    if (this.options.onElementSelected) {
      this.options.onElementSelected(info)
    }
  }

  // 当元素被悬停时通知观察者
  private notifyElementHover(info: ElementInfo) {
    if (this.options.onElementHover) {
      this.options.onElementHover(info)
    }
  }
}
```

### 11. 单例模式 (Singleton Pattern)

#### 11.1 Spring Bean 的单例管理

**使用位置**: 所有 Spring 管理的 Bean

**实现说明**:

- Spring 框架默认使用单例模式管理 Bean
- 确保服务类、工具类等在整个应用中只有一个实例

## 设计模式应用总结

### 架构层面的模式应用

1. **分层架构模式**: 项目采用经典的分层架构

   - Controller 层：处理 HTTP 请求
   - Service 层：业务逻辑处理
   - Core 层：核心功能实现（Facade、Parser、Saver）
   - AI 层：AI 服务相关
   - Utils 层：工具类

2. **模块化设计**:
   - 工具模块（ai.tools 包）
   - 工作流模块（langgraph4j 包）
   - 核心处理模块（core 包）

### 代码质量保证

1. **统一错误处理**: 使用 BusinessException 统一处理业务异常
2. **日志管理**: 使用@Slf4j 注解统一日志记录
3. **配置管理**: 使用@Configuration 集中管理配置

### 性能优化模式

1. **缓存模式**: AiCodeGeneratorServiceFactory 使用 Caffeine 缓存
2. **异步处理**: 使用 Reactor 的 Flux 进行流式处理
3. **资源池化**: AI 服务实例的缓存和复用

## 设计模式的优势

1. **可维护性**: 模式化的代码结构便于理解和维护
2. **可扩展性**: 工厂模式、策略模式等支持功能扩展
3. **复用性**: 模板方法模式、工具注册表模式提高代码复用
4. **松耦合**: 门面模式、依赖注入模式降低组件间耦合
5. **性能优化**: 单例模式、缓存模式提升系统性能

## 推荐的改进方向

1. **引入命令模式**: 可以考虑将工具调用封装为命令对象
2. **状态模式**: 工作流节点可以使用状态模式管理不同状态
3. **装饰器模式**: AI 服务可以使用装饰器模式添加监控、日志等功能
4. **责任链模式**: 请求处理可以使用责任链模式实现中间件功能

---

**文档版本**: 1.0  
**生成时间**: 2025-08-14  
**分析范围**: Mambo AI Platform 完整代码库
