# 对话历史
每次对话都是独立的，AI无法记住之前的交互内容。这导致用户无法基于已生成的网站进行迭代改进，极大地限制了平台的实用性。
举个例子：用户首先让AI生成一个博客网站，然后希望在此基础上添加评论功能，最后再优化一下页面样式。在没有对话记忆的情况下，每次都需要重新描述完整需求，AI也会重新生成整个网站，而不是在原有基础上进行改进。
因此，我们需要实现以下需求：
1)对话历史的持久化存储：用户发送消息时，需要保存用户消息；AI成功回复后，需要保存AI消息。即使AI回复失败，也要记录错误信息，确保对话的完整性。
2)应用级别的数据隔离：每个应用的对话历史都是独立的。删除应用时，需要关联删除该应用的所有对话历史，避免数据冗余。
3)对话历史查询：支持分页查看某个应用的对话历史，需要区分用户和AI消息。类似聊天软件的消息加载机制，每次加 载最新10条消息，支持向前加载更多历史记录。（仅应用创建者和管理员可见)详细来说，进入应用页面时，前端根据应用id先加载一次对话历史消息，关联查询最新10条消息。如果存在历史对话，直接展示；如果没有历史记录，才自动发送初始化提示词。这样就解决了之前浏览别人的应用时意外触发对话的问题。
4)管理对话历史：管理员可以查看所有应用的对话历史，按照时间降序排序，便于内容监管。

# 游标查询
Vibe Coding
```aiignore

请参考项目中已有的 User 和 APP 模块的文件和代码风格，帮我根据下列需求，生成完整的 ChatHistory 模块的后端代码。

## 需要的功能如下

1）对话历史的持久化存储：用户发送消息时，需要保存用户消息；AI 成功回复后，需要保存 AI 消息。即使 AI 回复失败，也要记录错误信息，确保对话的完整性。
2）应用级别的数据隔离：每个应用的对话历史都是独立的。删除应用时，需要关联删除该应用的所有对话历史，避免数据冗余。
3）对话历史查询：支持分页查看某个应用的对话历史，需要区分用户和 AI 消息。类似聊天软件的消息加载机制，每次加载最新 10 条消息，支持向前加载 更多历史记录。（仅应用创建者和管理员可见）
详细来说，进入应用页面时，前端根据应用 id 先加载一次对话历史消息，关联查询最新 10 条消息。如果存在历史对话，直接展示；如果没有历史记录，才自动发送初始化提示词。这样就解决了之前浏览别人的应用时意外触发对话的问题。
4）管理对话历史：管理员可以查看所有应用的对话历史，按照时间降序排序，便于内容监管。

## 实现提示

1）需要为 messageType 创建一个枚举类

```
mybatis-flex生成的实体类会打上@Builder注解，这样就可以用构造器方式来构造对象
# 对话记忆
LangChain4j不仅提供了对话记忆能力，而且还能结合Redis持久化对话记忆，非常爽~
1）为什么不直接用内存来存储会话记忆？
首先是重启后会丢失记忆；其次如果每个应用都在内存中维护对话历史，很容易出现OOM问题。
2）为什么不用MySQL来存储会话记忆?
一方面是因为Redis作为内存数据库，在读写对话记忆时性能更高；另一方面是数据库中的对话历史表包含其他业务字段，不适合直接交给LangChain4j的对话记忆组件管理。

加载历史
要注意，Redis的内存也不是无限的！一般情况下要给存入Redis的每个Key都设置合理的过期时间，不能不过期。所以这就可能导致Redis的会话记忆被删除的情况。

怎么解决呢?
方案很简单，之前我们已经在数据库中保存了用户和AI的消息，只需要在初始化会话记忆时，加载最新的对话记录到Re dis中，就能确保Al了解交互历史。
流程：AI对话=>从数据库中加载对话历史到Redis=>Redis为AI提供对话记忆

方法1 langchain4j官方实现
```java

interface Assistant  {
    String chat(@MemoryId int memoryId, @UserMessage String message);
}

Assistant assistant = AiServices.builder(Assistant.class)
    .chatModel(model)
    .chatMemoryProvider(memoryId -> MessageWindowChatMemory.withMaxMessages(10))
    .build();

String answerToKlaus = assistant.chat(1, "Hello, my name is Klaus");
String answerToFrancine = assistant.chat(2, "Hello, my name is Francine");

```

方法2 在aiservice上进行隔离
之前所有应用共用同一个AIService实例，如果想隔离会话记忆，可以给每个应用分配一个专属的AIService，每个AIService绑定独立的对话记忆。
修改ALService工厂类，提供根据 appld 获取AI Service服务的方法
为每一个app生成其自己的aiservice，这里可以进行优化
每一个app只需要生成一次aiservice，之后可以用缓存
此处采用caffeine缓存 caffeine就相当于是一个高级的map java中最好用的缓存
```java
    /**
     * AI 服务实例缓存
     * 缓存策略：
     * - 最大缓存 1000 个实例
     * - 写入后 30 分钟过期
     * - 访问后 10 分钟过期
     */
    private final Cache<Long, AiCodeGeneratorService> serviceCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .expireAfterAccess(Duration.ofMinutes(10))
            .removalListener((key, value, cause) -> {
                log.debug("AI 服务实例被移除，appId: {}, 原因: {}", key, cause);
            })
            .build();
```

现在还需要一个方法，在对话记忆初始化的时候，专门将数据库中的对话历史加载到Redis中。可以在应用创建时或AI服务初始化时调用这个方法。

1.查询起始点设置为1而不是0，这是为了排除最新的用户消息。因为在对话流程中，用户消息被添加到数据库后，Ai服务也会自动将用户消息添加到记忆中，如果不排除会导致消息重复。
2.注意反转从数据库中查到的消息列表，确保加载到记忆中的消息是按时间正序的。
3.加载前先清理Redis中的历史对话记忆，防止重复加载。

逻辑是这样的 在向ai提问前，先将用户消息添加到数据库，入库之后调用ai，在调用ai的时候，先获取到了对话记忆，对话记忆获取时，是先会从数据库中进行一次获取的。
此次获取的时候已经获取到了我们的第一条用户消息，所以在加载对话记忆的时候，我们需要从第二条开始加载。


# redis分布式session
```yaml
<!-- Spring Session + Redis -->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```
