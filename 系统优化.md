# 1.性能优化

![image-20250815083022113](D:\ideaproject\mambo-ai-platform\assets\image-20250815083022113.png)

![image-20250815083035352](D:\ideaproject\mambo-ai-platform\assets\image-20250815083035352.png)

单例模式->多例模式

![image-20250815083125119](D:\ideaproject\mambo-ai-platform\assets\image-20250815083125119.png)

```java
public class AiCodeGenTypeRoutingServiceFactory {

    /**
     * 创建AI代码生成类型路由服务实例
     */
    @Bean
    public AiCodeGenTypeRoutingService aiCodeGenTypeRoutingService() {
        // 多例模式生成bean
        ChatModel chatModel = SpringContextUtil.getBean("routingChatModelPrototype", ChatModel.class);
        return AiServices.builder(AiCodeGenTypeRoutingService.class)
                .chatModel(chatModel)
                .build();
    }
}
```

由于路由工厂并没有创建单独的aiservice，所以即便使用了多例模式的chatmodel，实际上还是调用的同一个aiservice->同一个chatmodel，所以需要每次创建一个新的aiservice

# 2.redis缓存优化

![image-20250815093200409](D:\ideaproject\mambo-ai-platform\assets\image-20250815093200409.png)

对于这种场景，我们采用最主流的旁路缓存模式：

1. 查询时先检查缓存，命中则直接返回
2. 缓存未命中则查询数据库，并将结果写入缓存
3. 设置合理的过期时间，无需主动删除缓存

![image-20250815093217270](D:\ideaproject\mambo-ai-platform\assets\image-20250815093217270.png)

使用Spring Data Redis来实现

现在需要根据用户查询条件来指定不同的key，springdataredis虽然给你提供了配置相关接口，但是里面没有过期时间，需要自己通过cachemanager来配置
```java
@Reflective
public @interface Cacheable {
    @AliasFor("cacheNames")
    String[] value() default {};

    @AliasFor("value")
    String[] cacheNames() default {};

    String key() default "";

    String keyGenerator() default "";

    String cacheManager() default "";

    String cacheResolver() default "";

    String condition() default "";

    String unless() default "";

    boolean sync() default false;
}
```

```java
@Configuration
public class RedisCacheManagerConfig {

    @Resource
    private RedisConnectionFactory redisConnectionFactory;

    @Bean
    public CacheManager cacheManager() {
        // 配置 ObjectMapper 支持 Java8 时间类型
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        
        // 默认配置
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30)) // 默认 30 分钟过期
                .disableCachingNullValues() // 禁用 null 值缓存
                // key 使用 String 序列化器
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                // value 使用 JSON 序列化器（支持复杂对象）
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer(objectMapper)));
        
        return RedisCacheManager.builder(redisConnectionFactory)
                .cacheDefaults(defaultConfig)
                // 针对 good_app_page 配置5分钟过期
                .withCacheConfiguration("good_app_page",
                        defaultConfig.entryTtl(Duration.ofMinutes(5)))
                .build();
    }
}
```

```java
    @PostMapping("/good/list/page/vo")
    @Cacheable(value = "good_app_page", key = "T(com.hachimi.mamboaiplatform.utils.CacheKeyUtil).generateKey(#appQueryRequest)")//调用这个类里面的指定方法
    public BaseResponse<Page<AppVO>> listGoodAppVOByPage(@RequestBody AppQueryRequest appQueryRequest) {
        ThrowUtils.throwIf(appQueryRequest == null, ErrorCode.PARAMS_ERROR);
        // 限制每页最多 20 个
        long pageSize = appQueryRequest.getPageSize();
        ThrowUtils.throwIf(pageSize > 20, ErrorCode.PARAMS_ERROR, "每页最多查询 20 个应用");
        long pageNum = appQueryRequest.getPageNum();
        // 只查询精选的应用
        appQueryRequest.setPriority(AppConstant.GOOD_APP_PRIORITY);
        QueryWrapper queryWrapper = appService.getQueryWrapper(appQueryRequest);
        // 分页查询
        Page<App> appPage = appService.page(Page.of(pageNum, pageSize), queryWrapper);
        // 数据封装
        Page<AppVO> appVOPage = new Page<>(pageNum, pageSize, appPage.getTotalRow());
        List<AppVO> appVOList = appService.getAppVOList(appPage.getRecords());
        appVOPage.setRecords(appVOList);
        return ResultUtils.success(appVOPage);
    }
```

![image-20250815095649304](D:\ideaproject\mambo-ai-platform\assets\image-20250815095649304.png)

但是要注意，如果对value进行JSON序列化，可能会出现无法反序列化的情况，因为Redis中并没有存储Java类的
信息，不知道要反序列化成哪个类，就会报错

两种方式解决redis缓存时无法知道你要缓存的内容具体是哪个类
1.baseresponse中加上无参构造器
然后再rediscachemanagerconfig中指定序列化默认类型
2.不使用json序列化器，就使用普通的序列化器

# 3.实时性优化

之前有提到，如果是Vue工程模式生成，用户在AI生成完代码后无法实时浏览到网站效果，或者看到的还是旧版本的页面。这是因为我们之前采用的是异步打包策略，当用户看到AI回复完成时，Vue项目可能还在后台构建中，存在时间差。

![image-20250815103027995](D:\ideaproject\mambo-ai-platform\assets\image-20250815103027995.png)

![image-20250815103454983](D:\ideaproject\mambo-ai-platform\assets\image-20250815103454983.png)

因为html也类似于同步打包，所以统一整体的项目实现逻辑

# 4.安全性优化

![image-20250815104901373](D:\ideaproject\mambo-ai-platform\assets\image-20250815104901373.png)

![image-20250815104937849](D:\ideaproject\mambo-ai-platform\assets\image-20250815104937849.png)

![image-20250815105000364](D:\ideaproject\mambo-ai-platform\assets\image-20250815105000364.png)

# 5.prompt安全检查

除了流量保护，我们还需要防范恶意输入和Prompt注入攻击。美团NoCode也有一些防护的策略，比如在将prompt交给Al执行之前，会进行一次审核
![image-20250815112538463](D:\ideaproject\mambo-ai-platform\assets\image-20250815112538463.png)

![image-20250815112553479](D:\ideaproject\mambo-ai-platform\assets\image-20250815112553479.png)

## 6.稳定性优化

![image-20250815113809530](D:\ideaproject\mambo-ai-platform\assets\image-20250815113809530.png)

![image-20250815113914132](D:\ideaproject\mambo-ai-platform\assets\image-20250815113914132.png)

# 7.成本优化
