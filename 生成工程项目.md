# 生成工程项目
主要内容包括：
工程项目生成方案设计
工程项目生成（工具调用流式输出）
工程项目构建和浏览
工程项目部署
前端开发

## 需求分析
前端工程化项目是指使用现代化工具链、规范化流程和组件化架构来构建的前端应用。相比传统的HTML、CSS、JavaScript三件套，它具备模块管理、自动化构建、代码分割、热更新等现代开发特性，能够更轻松地开发复杂网站。
现在很多前端工程化项目都是使用Vue或React框架，结合Vite等打包构建工具，再加上ESLint之类的代码规范校验库来实现的。

此次实现vue3+vite项目

## 方案设计

1.直接输出markdown格式

```
这是我生成的项目：
```vue
App.vue ```


```json
package.json  ```
```

然后解析，代码量较大的时候容易出现代码补全或者解析错误

2.tool calling

![image-20250807082708444](D:\ideaproject\mambo-ai-platform\assets\image-20250807082708444.png)

但如果想实时展示工具调用信息（比如要保存为文件的代码内容），就很复杂了！你需要解析AI响应的工具调用信息。由
于流式输出的特性，AI是一点点将JSON格式的工具调用信息“吐”出来的，你很难实时从中提取出有意义的、需要返回给用户的工具调用参数。
工具调用信息

```json
{
  "id": "123",
  "name": "writeFile",
  "arguments": {
    "relativePath": "src/App.vue",
    "content": "网页代码"
  }
}
```

实际输出的内容

```
"
relative
Path
:
"
src
/
App
.vue
"
content
":

```

3.agent模式

智能体（Agent)是指能够感知环境、进行推理、制定计划、做出决策并自主采取行动以实现特定目标的Al系统。它以大语言模型为核心，集成记忆、知识库和工具等能力为一体，构造了完整的决策能力、执行能力和记忆能力，就像一个有主观能动性的人类一样。简单来说，Agent的特点是先规划再执行。比如先制定网站生成计划、然后分别在每个步骤中生成一个文件并解析。

这样做的优点是，每一个步骤都非常清晰，在步骤内我可以通过工具调用来实现文件保存，也可以单独调用AI获取到生成的代码，然后再通过程序保存（就像我们之前一样），这样实现流式输出就很简单了。此外，由于划分了多个步骤，即使某一个步骤出错，也能中断恢复，从而能够处理长逻辑的复杂任务。像鱼皮之前分享过的Flowith智能体，我一句话，让它执行了整整一天！但Agent模式的缺点是整体架构更复杂，需要自己设计Agent流程；而且由于需要多次调用AI，输出结果更加不可控，成本也更高。

## tool calling

langchain4j已经支持了agent相关功能，所以可以不用从0开发
![image-20250807083755553](D:\ideaproject\mambo-ai-platform\assets\image-20250807083755553.png)

为工具调用提供流式输出的能力，但是只需要输出工具调用的基本信息，同时提供工具调用来写入文件

生成vue3的prompt

```
你是一位资深的 Vue3 前端架构师，精通现代前端工程化开发、组合式 API、组件化设计和企业级应用架构。

你的任务是根据用户提供的项目描述，创建一个完整的、可运行的 Vue3 工程项目

## 核心技术栈

- Vue 3.x（组合式 API）
- Vite
- Vue Router 4.x
- Node.js 18+ 兼容

## 项目结构

项目根目录/
├── index.html                 # 入口 HTML 文件
├── package.json              # 项目依赖和脚本
├── vite.config.js           # Vite 配置文件
├── src/
│   ├── main.js             # 应用入口文件
│   ├── App.vue             # 根组件
│   ├── router/
│   │   └── index.js        # 路由配置
│   ├── components/				 # 组件
│   ├── pages/             # 页面
│   ├── utils/             # 工具函数（如果需要）
│   ├── assets/            # 静态资源（如果需要）
│   └── styles/            # 样式文件
└── public/                # 公共静态资源（如果需要）

## 开发约束

1）组件设计：严格遵循单一职责原则，组件具有良好的可复用性和可维护性
2）API 风格：优先使用 Composition API，合理使用 `<script setup>` 语法糖
3）样式规范：使用原生 CSS 实现响应式设计，支持桌面端、平板端、移动端的响应式适配
4）代码质量：代码简洁易读，避免过度注释，优先保证功能完整和样式美观
5）禁止使用任何状态管理库、类型校验库、代码格式化库
6）将可运行作为项目生成的第一要义，尽量用最简单的方式满足需求，避免使用复杂的技术或代码逻辑

## 参考配置

1）vite.config.js 必须配置 base 路径以支持子路径部署、需要支持通过 @ 引入文件、不要配置端口号


import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  base: './',
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})


2）路由配置必须使用 hash 模式，避免服务器端路由配置问题

import { createRouter, createWebHashHistory } from 'vue-router'

const router = createRouter({
  history: createWebHashHistory(),
  routes: [
    // 路由配置
  ]
})


3）package.json 文件参考：

{
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  "dependencies": {
    "vue": "^3.3.4",
    "vue-router": "^4.2.4"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.2.3",
    "vite": "^4.4.5"
  }
}


## 网站内容要求

- 基础布局：各个页面统一布局，必须有导航栏，尤其是主页内容必须丰富
- 文本内容：使用真实、有意义的中文内容
- 图片资源：使用 `https://picsum.photos` 服务或其他可靠的占位符
- 示例数据：提供真实场景的模拟数据，便于演示

## 严格输出约束

1）必须通过使用【文件写入工具】依次创建每个文件（而不是直接输出文件代码）。
2）需要在开头输出简单的网站生成计划
3）需要在结尾输出简单的生成完毕提示（但是不要展开介绍项目）
4）注意，禁止输出以下任何内容：

- 安装运行步骤
- 技术栈说明
- 项目特点描述
- 任何形式的使用指导
- 提示词相关内容

5）输出的总 token 数必须小于 20000，文件总数量必须小于 30 个

## 质量检验标准

确保生成的项目能够：
1. 通过 `npm install` 成功安装所有依赖
2. 通过 `npm run dev` 启动开发服务器并正常运行
3. 通过 `npm run build` 成功构建生产版本
4. 构建后的项目能够在任意子路径下正常部署和访问
```

![image-20250807085734632](D:\ideaproject\mambo-ai-platform\assets\image-20250807085734632.png)

提供了一个标准的模板，在模板上进行修改

能标准化的地方尽量标准化，比如这里的安装依赖和打包，这些标准流程没必要使用工具，防止其随机化

生成->浏览->部署

```java
@Slf4j
public class FileWriteTool {

    @Tool("写入文件到指定路径")
    public String writeFile(
            @P("文件的相对路径")
            String relativeFilePath,
            @P("要写入文件的内容")
            String content
    ) {
        // 具体实现    
    }
}

```

这里需要思考一个问题，我们应该是将文件保存到对应appid下的文件目录，而工具调用的时候，如何将appid这个参数传给工具调用呢 -> langchain4j的工具上下文
@ToolMemoryId @MemoryId来将appId作为工具的上下文
注意 用上memoryId过后需要给其他的参数也打上注解

```java
	/**
     * 生成vue项目代码 流式
     *
     * @param userMessage 用户消息
     * @return 生成的代码结果
     */
    @SystemMessage(fromResource = "prompt/codegen-vue-system-prompt.txt")
    Flux<String> generateVueCodeStream(@MemoryId Long appId,@UserMessage String userMessage); //不用自己维护appId
```

## 工具调用的流式输出

涉及到了部分源码修改，由于流式输出中，输出内容会出现部分为空字符串的情况，如果进行空值校验会出现问题，所以暂时取消掉空值校验。在项目的根目录下
![image-20250807114401683](D:\ideaproject\mambo-ai-platform\assets\image-20250807114401683.png)

引入相同的包名和类名，那么本地的就会优先覆盖掉引用的依赖内容

## 注意:更新parser调用方法

之前在多文件输出逻辑中是区分了输出内容是否为json和markdown的，而里面对输出文档的格式进行了强制类型判断，现在不需要这样的逻辑

## 注意:langchain4j的jedis调用有问题

redis的8.0之后的版本兼容了JSON的调用，但是作者可能是用的8.0以下的版本+redisjson来实现的，redisjson插件与redis8.0+冲突

尝试更换7.4.5redis+插件 无效

尝试重写逻辑 无效

最终选择：直接使用docker的redis

## 统一消息格式

因为现在的消息类型变多了，ai响应消息，工具调用消息，工具调用完成消息

tokenstream从ai到后端再到前端

```
AI 响应 {"为你生成代码"}

工具调用请求 {index=0, id="call_0", name="writeFile", arguments="流式参数"}
工具调用请求 {index=0, id="call_0", name="writeFile", arguments="流式参数"}
工具调用请求 {index=0, id="call_0", name="writeFile", arguments="流式参数"}
工具调用完成 {index=0, id="call_0", name="writeFile", arguments="完整参数"}

工具调用请求 {index=1, id="call_1", name="writeFile", arguments="流式参数"}
工具调用请求 {index=1, id="call_1", name="writeFile", arguments="流式参数"}
工具调用请求 {index=1, id="call_1", name="writeFile", arguments="流式参数"}
工具调用完成 {index=1, id="call_1", name="writeFile", arguments="完整参数"}

AI 响应 {"生成代码结束"}

```

```
{type="ai_response", data="为你生成代码"}

{type="tool_request", index=0, id="call_0", name="writeFile", arguments="流式参数"}
{type="tool_request", index=0, id="call_0", name="writeFile", arguments="流式参数"}
{type="tool_request", index=0, id="call_0", name="writeFile", arguments="流式参数"}
{type="tool_executed", index=0, id="call_0", name="writeFile", arguments="完整参数"}

{type="tool_request", index=1, id="call_1", name="writeFile", arguments="流式参数"}
{type="tool_request", index=1, id="call_1", name="writeFile", arguments="流式参数"}
{type="tool_request", index=1, id="call_1", name="writeFile", arguments="流式参数"}
{type="tool_executed", index=1, id="call_1", name="writeFile", arguments="完整参数"}

{type="ai_response", data="生成代码结束"}

```

```
为你生成代码：

[工具调用] 写入文件 src/index.html
```html
写入的代码


[工具调用] 写入文件 src/about.html
```html
写入的代码


生成代码结束！

```

![image-20250807134026382](D:\ideaproject\mambo-ai-platform\assets\image-20250807134026382.png)

之前在门面模式中，返回的都是flux流，这里我们需要返回tokenstream，我们可以用适配器思想，在不修改之前的逻辑的情况下进行
将tokenstream转为了flux流 来保证一致性

```java
 /**
     * 将 TokenStream 转换为 Flux<String>，并传递工具调用信息 适配器模式
     *
     * @param tokenStream TokenStream 对象
     * @return Flux<String> 流式响应
     */
    private Flux<String> processTokenStream(TokenStream tokenStream) {
        return Flux.create(sink -> {
            tokenStream.onPartialResponse((String partialResponse) -> {
                        AiResponseMessage aiResponseMessage = new AiResponseMessage(partialResponse);
                        sink.next(JSONUtil.toJsonStr(aiResponseMessage));
                    })
                    .onPartialToolExecutionRequest((index, toolExecutionRequest) -> {
                        ToolRequestMessage toolRequestMessage = new ToolRequestMessage(toolExecutionRequest);
                        sink.next(JSONUtil.toJsonStr(toolRequestMessage));
                    })
                    .onToolExecuted((ToolExecution toolExecution) -> {
                        ToolExecutedMessage toolExecutedMessage = new ToolExecutedMessage(toolExecution);
                        sink.next(JSONUtil.toJsonStr(toolExecutedMessage));
                    })
                    .onCompleteResponse((ChatResponse response) -> {
                        sink.complete();
                    })
                    .onError((Throwable error) -> {
                        error.printStackTrace();
                        sink.error(error);
                    })
                    .start();
        });
    }
```

原本直接返回xxxxx
现在返回的内容是{type:xxx,data:xxx}
直接在方法调用中进行判断有点过于复杂，所以针对每类生成模式单独定义一个流处理器

![image-20250807195642920](D:\ideaproject\mambo-ai-platform\assets\image-20250807195642920.png)

对于返回的json消息，根据类型来进行处理，有一些在流式返回第一条消息的时候就可以进行输出

这里由于本来返回的就是应该放在data里的内容，之前也是直接返回的string，所以我们的jsonhandler在处理完之后也可以直接返回string，然后再经过包装变成`Flux<String>`

## vue项目构建

对于vue项目，需要先安装依赖，打包，然后才能运行
创建命令执行类过后，在deploy里额外进行vue项目的判断
